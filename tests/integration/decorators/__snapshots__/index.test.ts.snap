// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`decorators default to 2022-03 1`] = `
"var _dec, _initClass;
let _Person;
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = function() {
        function createAddInitializerMethod(initializers, decoratorFinishedRef) {
            return function(initializer) {
                (function(decoratorFinishedRef, fnName) {
                    if (decoratorFinishedRef.v) throw Error("attempted to call " + fnName + " after decoration was finished");
                })(decoratorFinishedRef, "addInitializer"), assertCallable(initializer, "An initializer"), initializers.push(initializer);
            };
        }
        function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
            switch(kind){
                case 1:
                    kindStr = "accessor";
                    break;
                case 2:
                    kindStr = "method";
                    break;
                case 3:
                    kindStr = "getter";
                    break;
                case 4:
                    kindStr = "setter";
                    break;
                default:
                    kindStr = "field";
            }
            var kindStr, get, set, ctx = {
                kind: kindStr,
                name: isPrivate ? "#" + name : name,
                static: isStatic,
                private: isPrivate,
                metadata: metadata
            }, decoratorFinishedRef = {
                v: !1
            };
            ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef), 0 === kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = function() {
                return this[name];
            }, set = function(v) {
                this[name] = v;
            }) : 2 === kind ? get = function() {
                return desc.value;
            } : ((1 === kind || 3 === kind) && (get = function() {
                return desc.get.call(this);
            }), (1 === kind || 4 === kind) && (set = function(v) {
                desc.set.call(this, v);
            })), ctx.access = get && set ? {
                get: get,
                set: set
            } : get ? {
                get: get
            } : {
                set: set
            };
            try {
                return dec(value, ctx);
            } finally{
                decoratorFinishedRef.v = !0;
            }
        }
        function assertCallable(fn, hint) {
            if ("function" != typeof fn) throw TypeError(hint + " must be a function");
        }
        function assertValidReturnValue(kind, value) {
            var hint, type = typeof value;
            if (1 === kind) {
                if ("object" !== type || null === value) throw TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
                void 0 !== value.get && assertCallable(value.get, "accessor.get"), void 0 !== value.set && assertCallable(value.set, "accessor.set"), void 0 !== value.init && assertCallable(value.init, "accessor.init");
            } else if ("function" !== type) throw TypeError((hint = 0 === kind ? "field" : 10 === kind ? "class" : "method") + " decorators must return a function or void 0");
        }
        function pushInitializers(ret, initializers) {
            initializers && ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++)initializers[i].call(instance);
                return instance;
            });
        }
        function defineMetadata(Class, metadata) {
            return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
                configurable: !0,
                enumerable: !0,
                value: metadata
            });
        }
        return function(targetClass, memberDecs, classDecs, parentClass) {
            if (void 0 !== parentClass) var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
            var metadata = Object.create(void 0 === parentMetadata ? null : parentMetadata), e = function(Class, decInfos, metadata) {
                for(var ret = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++){
                    var protoInitializers, staticInitializers, base, initializers, decInfo = decInfos[i];
                    if (Array.isArray(decInfo)) {
                        var kind = decInfo[1], name = decInfo[2], isPrivate = decInfo.length > 3, isStatic = kind >= 5;
                        if (isStatic ? (base = Class, kind -= 5, initializers = staticInitializers = staticInitializers || []) : (base = Class.prototype, initializers = protoInitializers = protoInitializers || []), 0 !== kind && !isPrivate) {
                            var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields, existingKind = existingNonFields.get(name) || 0;
                            if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                            !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);
                        }
                        !function(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
                            var desc, init, value, newValue, get, set, newInit, decs = decInfo[0];
                            if (isPrivate ? desc = 0 === kind || 1 === kind ? {
                                get: decInfo[3],
                                set: decInfo[4]
                            } : 3 === kind ? {
                                get: decInfo[3]
                            } : 4 === kind ? {
                                set: decInfo[3]
                            } : {
                                value: decInfo[3]
                            } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {
                                get: desc.get,
                                set: desc.set
                            } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), "function" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, value = {
                                get: get,
                                set: set = newValue.set || value.set
                            }) : value = newValue);
                            else for(var i = decs.length - 1; i >= 0; i--){
                                ;
                                void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, metadata, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, value = {
                                    get: get,
                                    set: set = newValue.set || value.set
                                }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : "function" == typeof init ? init = [
                                    init,
                                    newInit
                                ] : init.push(newInit)));
                            }
                            if (0 === kind || 1 === kind) {
                                if (void 0 === init) init = function(instance, init) {
                                    return init;
                                };
                                else if ("function" != typeof init) {
                                    var ownInitializers = init;
                                    init = function(instance, init) {
                                        for(var value = init, i = 0; i < ownInitializers.length; i++)value = ownInitializers[i].call(instance, value);
                                        return value;
                                    };
                                } else {
                                    var originalInitializer = init;
                                    init = function(instance, init) {
                                        return originalInitializer.call(instance, init);
                                    };
                                }
                                ret.push(init);
                            }
                            0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function(instance, args) {
                                return value.get.call(instance, args);
                            }), ret.push(function(instance, args) {
                                return value.set.call(instance, args);
                            })) : 2 === kind ? ret.push(value) : ret.push(function(instance, args) {
                                return value.call(instance, args);
                            }) : Object.defineProperty(base, name, desc));
                        }(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
                    }
                }
                return pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;
            }(targetClass, memberDecs, metadata);
            return !classDecs.length && defineMetadata(targetClass, metadata), {
                e: e,
                get c () {
                    return function(targetClass, classDecs, metadata) {
                        if (classDecs.length > 0) {
                            for(var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--){
                                var decoratorFinishedRef = {
                                    v: !1
                                };
                                try {
                                    var nextNewClass = classDecs[i](newClass, {
                                        kind: "class",
                                        name: name,
                                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                                        metadata
                                    });
                                } finally{
                                    decoratorFinishedRef.v = !0;
                                }
                                void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);
                            }
                            return [
                                defineMetadata(newClass, metadata),
                                function() {
                                    for(var i = 0; i < initializers.length; i++)initializers[i].call(newClass);
                                }
                            ];
                        }
                    }(targetClass, classDecs, metadata);
                }
            };
        };
    }())(targetClass, memberDecs, classDecs, parentClass);
}
_dec = function(target) {
    target.prototype.name = 'rslib';
};
class Person {
    static{
        ({ c: [_Person, _initClass] } = _apply_decs_2203_r(this, [], [
            _dec
        ]));
    }
    constructor(){
        this.version = '1.0.0';
    }
    version;
    static{
        _initClass();
    }
}
export { _Person as Person };
"
`;

exports[`decorators with experimentalDecorators in tsconfig 1`] = `
"function _ts_metadata(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}
class Person {
    constructor(){
        this.version = '1.0.0';
    }
}
Person = function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}([
    function(target) {
        target.prototype.name = 'rslib';
    },
    _ts_metadata("design:type", Function),
    _ts_metadata("design:paramtypes", [])
], Person);
export { Person };
"
`;

exports[`decorators with experimentalDecorators in tsconfig 2`] = `
"var _dec, _initClass;
let _Person;
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = function() {
        function createAddInitializerMethod(initializers, decoratorFinishedRef) {
            return function(initializer) {
                (function(decoratorFinishedRef, fnName) {
                    if (decoratorFinishedRef.v) throw Error("attempted to call " + fnName + " after decoration was finished");
                })(decoratorFinishedRef, "addInitializer"), assertCallable(initializer, "An initializer"), initializers.push(initializer);
            };
        }
        function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
            switch(kind){
                case 1:
                    kindStr = "accessor";
                    break;
                case 2:
                    kindStr = "method";
                    break;
                case 3:
                    kindStr = "getter";
                    break;
                case 4:
                    kindStr = "setter";
                    break;
                default:
                    kindStr = "field";
            }
            var kindStr, get, set, ctx = {
                kind: kindStr,
                name: isPrivate ? "#" + name : name,
                static: isStatic,
                private: isPrivate,
                metadata: metadata
            }, decoratorFinishedRef = {
                v: !1
            };
            ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef), 0 === kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = function() {
                return this[name];
            }, set = function(v) {
                this[name] = v;
            }) : 2 === kind ? get = function() {
                return desc.value;
            } : ((1 === kind || 3 === kind) && (get = function() {
                return desc.get.call(this);
            }), (1 === kind || 4 === kind) && (set = function(v) {
                desc.set.call(this, v);
            })), ctx.access = get && set ? {
                get: get,
                set: set
            } : get ? {
                get: get
            } : {
                set: set
            };
            try {
                return dec(value, ctx);
            } finally{
                decoratorFinishedRef.v = !0;
            }
        }
        function assertCallable(fn, hint) {
            if ("function" != typeof fn) throw TypeError(hint + " must be a function");
        }
        function assertValidReturnValue(kind, value) {
            var hint, type = typeof value;
            if (1 === kind) {
                if ("object" !== type || null === value) throw TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
                void 0 !== value.get && assertCallable(value.get, "accessor.get"), void 0 !== value.set && assertCallable(value.set, "accessor.set"), void 0 !== value.init && assertCallable(value.init, "accessor.init");
            } else if ("function" !== type) throw TypeError((hint = 0 === kind ? "field" : 10 === kind ? "class" : "method") + " decorators must return a function or void 0");
        }
        function pushInitializers(ret, initializers) {
            initializers && ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++)initializers[i].call(instance);
                return instance;
            });
        }
        function defineMetadata(Class, metadata) {
            return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
                configurable: !0,
                enumerable: !0,
                value: metadata
            });
        }
        return function(targetClass, memberDecs, classDecs, parentClass) {
            if (void 0 !== parentClass) var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
            var metadata = Object.create(void 0 === parentMetadata ? null : parentMetadata), e = function(Class, decInfos, metadata) {
                for(var ret = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++){
                    var protoInitializers, staticInitializers, base, initializers, decInfo = decInfos[i];
                    if (Array.isArray(decInfo)) {
                        var kind = decInfo[1], name = decInfo[2], isPrivate = decInfo.length > 3, isStatic = kind >= 5;
                        if (isStatic ? (base = Class, kind -= 5, initializers = staticInitializers = staticInitializers || []) : (base = Class.prototype, initializers = protoInitializers = protoInitializers || []), 0 !== kind && !isPrivate) {
                            var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields, existingKind = existingNonFields.get(name) || 0;
                            if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                            !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);
                        }
                        !function(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
                            var desc, init, value, newValue, get, set, newInit, decs = decInfo[0];
                            if (isPrivate ? desc = 0 === kind || 1 === kind ? {
                                get: decInfo[3],
                                set: decInfo[4]
                            } : 3 === kind ? {
                                get: decInfo[3]
                            } : 4 === kind ? {
                                set: decInfo[3]
                            } : {
                                value: decInfo[3]
                            } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {
                                get: desc.get,
                                set: desc.set
                            } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), "function" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, value = {
                                get: get,
                                set: set = newValue.set || value.set
                            }) : value = newValue);
                            else for(var i = decs.length - 1; i >= 0; i--){
                                ;
                                void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, metadata, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, value = {
                                    get: get,
                                    set: set = newValue.set || value.set
                                }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : "function" == typeof init ? init = [
                                    init,
                                    newInit
                                ] : init.push(newInit)));
                            }
                            if (0 === kind || 1 === kind) {
                                if (void 0 === init) init = function(instance, init) {
                                    return init;
                                };
                                else if ("function" != typeof init) {
                                    var ownInitializers = init;
                                    init = function(instance, init) {
                                        for(var value = init, i = 0; i < ownInitializers.length; i++)value = ownInitializers[i].call(instance, value);
                                        return value;
                                    };
                                } else {
                                    var originalInitializer = init;
                                    init = function(instance, init) {
                                        return originalInitializer.call(instance, init);
                                    };
                                }
                                ret.push(init);
                            }
                            0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function(instance, args) {
                                return value.get.call(instance, args);
                            }), ret.push(function(instance, args) {
                                return value.set.call(instance, args);
                            })) : 2 === kind ? ret.push(value) : ret.push(function(instance, args) {
                                return value.call(instance, args);
                            }) : Object.defineProperty(base, name, desc));
                        }(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
                    }
                }
                return pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;
            }(targetClass, memberDecs, metadata);
            return !classDecs.length && defineMetadata(targetClass, metadata), {
                e: e,
                get c () {
                    return function(targetClass, classDecs, metadata) {
                        if (classDecs.length > 0) {
                            for(var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--){
                                var decoratorFinishedRef = {
                                    v: !1
                                };
                                try {
                                    var nextNewClass = classDecs[i](newClass, {
                                        kind: "class",
                                        name: name,
                                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                                        metadata
                                    });
                                } finally{
                                    decoratorFinishedRef.v = !0;
                                }
                                void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);
                            }
                            return [
                                defineMetadata(newClass, metadata),
                                function() {
                                    for(var i = 0; i < initializers.length; i++)initializers[i].call(newClass);
                                }
                            ];
                        }
                    }(targetClass, classDecs, metadata);
                }
            };
        };
    }())(targetClass, memberDecs, classDecs, parentClass);
}
_dec = function(target) {
    target.prototype.name = 'rslib';
};
class Person {
    static{
        ({ c: [_Person, _initClass] } = _apply_decs_2203_r(this, [], [
            _dec
        ]));
    }
    constructor(){
        this.version = '1.0.0';
    }
    version;
    static{
        _initClass();
    }
}
export { _Person as Person };
"
`;
